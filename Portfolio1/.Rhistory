model <- lm(mpg ~ cyl, data = mtcars)
# Plot
ggplot(mtcars, aes(x = cyl, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red")
# Load necessary library
library(ggplot2)
# Fit the model
model <- glm(vs ~ mpg, data = mtcars, family = binomial)
# Plot
ggplot(mtcars, aes(x = mpg, y = vs)) +
geom_point() +
geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE, color = "red")
# Load necessary library
library(corrplot)
# Generate some data
data(mtcars)
# Compute correlation matrix
correlation_matrix <- cor(mtcars)
# Create correlation plot
corrplot(correlation_matrix, method = "circle")
# Load necessary library
library(ggplot2)
# Fit the model
model <- lm(mpg ~ cyl, data = mtcars)
# Plot
ggplot(mtcars, aes(x = cyl, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red")
# Load necessary library
library(ggplot2)
# Fit the model
model <- glm(vs ~ mpg, data = mtcars, family = binomial)
# Plot
ggplot(mtcars, aes(x = mpg, y = vs)) +
geom_point() +
geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE, color = "red")
# Load the necessary library
library(ggplot2)
library(readr)
# Read the dataset
#your code here
df <- read.csv("Pokemon.csv")
# View the first few rows of the dataframe
#head(df)
head(df)
# Get a summary of the dataframe
#summary(df)
summary(df)
# Load the necessary library
library(ggplot2)
# Create a histogram of the Total variable
#your code here
hist(df$Total, main = "Histogram of Total Base Stats", xlab = "Total", col = "green")
#your code here
library(reshape2)
library(tidyr)
Pokemon <- data.frame(
HP = c(10, 45, 60, 64.21, 80, 250),
Attack = c(5, 51, 70, 72.55, 90, 134),
Defense = c(5, 50, 65, 68.23, 84, 180),
'Sp. Atk' =c(15, 45, 65, 67.14, 87.50, 154),
'Sp. Def' =c(20, 49, 65, 66.02, 80, 125),
Speed = c(15, 46.5, 70, 68.93, 90, 140)
)
Pokemon_long <- tidyr::gather(Pokemon, key = "Stat", value = "Value")
ggplot(Pokemon_long, aes (x = Stat, y = Value, fill = Stat)) +
geom_boxplot() +
ggtitle("Box Plot of Pokemon Status") +
xlab("Stat") +
ylab("Stat Value") +
scale_fill_manual(values = c("red", "green", "purple", "blue", "yellow", "pink", "lightgreen")) +
theme_minimal()
#your code here
STAGE <- factor(df$Stage)
ggplot(df, aes(x = Attack, y = Defense,  color = STAGE)) +
geom_point(size=3) +
labs(title = "Scatter Plot of Attack vs Defense with Stage")
x = "Attack"
y = "Defense" +
theme_minimal() + scale_color_manual(values = c("darkblue", "darkgreen", "darkred"))
# Load necessary library
library(corrplot)
# Generate some data
data(mtcars)
# Compute correlation matrix
correlation_matrix <- cor(mtcars)
# Create correlation plot
corrplot(correlation_matrix, method = "circle")
# Load necessary library
library(ggplot2)
# Fit the model
model <- lm(mpg ~ cyl, data = mtcars)
# Plot
ggplot(mtcars, aes(x = cyl, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red")
# Load necessary library
library(ggplot2)
# Fit the model
model <- glm(vs ~ mpg, data = mtcars, family = binomial)
# Plot
ggplot(mtcars, aes(x = mpg, y = vs)) +
geom_point() +
geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE, color = "red")
# Load necessary library
library(corrplot)
# Generate some data
data(mtcars)
# Compute correlation matrix
correlation_matrix <- cor(mtcars)
# Create correlation plot
corrplot(correlation_matrix, method = "circle")
# Load necessary library
library(ggplot2)
# Fit the model
model <- glm(vs ~ mpg, data = mtcars, family = binomial)
# Plot
ggplot(mtcars, aes(x = mpg, y = vs)) +
geom_point() +
geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE, color = "red")
# Load necessary library
library(ggplot2)
# Fit the model
model <- lm(mpg ~ cyl, data = mtcars)
# Plot
ggplot(mtcars, aes(x = cyl, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red")
install.packages("sf", dependencies=TRUE)
install.packages("tmap", dependencies=TRUE)
install.packages("mapview", dependencies=TRUE)
install.packages("stars", dependencies=TRUE)
install.packages("rayshader", dependencies=TRUE)
install.packages("MetBrewer", dependencies=TRUE)
install.packages("rayrender")
install.packages("extrafont", dependencies=TRUE)
install.packages("magick", dependencies=TRUE)
# Load the necessary library
library(ggplot2)
library(readr)
# Read the dataset
#your code here
df <- read.csv("Pokemon.csv")
# View the first few rows of the dataframe
#head(df)
head(df)
# Get a summary of the dataframe
#summary(df)
summary(df)
# Load the necessary library
library(ggplot2)
# Create a histogram of the Total variable
#your code here
hist(df$Total, main = "Histogram of Total Base Stats", xlab = "Total", col = "green")
#your code here
library(reshape2)
library(tidyr)
Pokemon <- data.frame(
HP = c(10, 45, 60, 64.21, 80, 250),
Attack = c(5, 51, 70, 72.55, 90, 134),
Defense = c(5, 50, 65, 68.23, 84, 180),
'Sp. Atk' =c(15, 45, 65, 67.14, 87.50, 154),
'Sp. Def' =c(20, 49, 65, 66.02, 80, 125),
Speed = c(15, 46.5, 70, 68.93, 90, 140)
)
Pokemon_long <- tidyr::gather(Pokemon, key = "Stat", value = "Value")
ggplot(Pokemon_long, aes (x = Stat, y = Value, fill = Stat)) +
geom_boxplot() +
ggtitle("Box Plot of Pokemon Status") +
xlab("Stat") +
ylab("Stat Value") +
scale_fill_manual(values = c("red", "green", "purple", "blue", "yellow", "pink", "lightgreen")) +
theme_minimal()
#your code here
STAGE <- factor(df$Stage)
ggplot(df, aes(x = Attack, y = Defense,  color = STAGE)) +
geom_point(size=3) +
labs(title = "Scatter Plot of Attack vs Defense with Stage")
x = "Attack"
y = "Defense" +
theme_minimal() + scale_color_manual(values = c("darkblue", "darkgreen", "darkred"))
# Load necessary library
library(corrplot)
# Generate some data
data(mtcars)
# Compute correlation matrix
correlation_matrix <- cor(mtcars)
# Create correlation plot
corrplot(correlation_matrix, method = "circle")
# Load necessary library
library(ggplot2)
# Fit the model
model <- lm(mpg ~ cyl, data = mtcars)
# Plot
ggplot(mtcars, aes(x = cyl, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red")
# Load necessary library
library(ggplot2)
# Fit the model
model <- glm(vs ~ mpg, data = mtcars, family = binomial)
# Plot
ggplot(mtcars, aes(x = mpg, y = vs)) +
geom_point() +
geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE, color = "red")
ph_hex <- st_read("data/kontur_population_PH_20231101.gpkg") %>% st_transform(3106)
ph_hex <- st_read("data/kontur_population_PH_20231101.gpkg") %>% st_transform(3106)
ph_admin <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
options(rgl.useNULL = FALSE)
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
ph_hex <- st_read("data/kontur_population_PH_20231101.gpkg") %>% st_transform(3106)
/Users/keithlaspona/Downloads/Portfolio 1 Resources-20240310/data/kontur_boundaries_PH_20230628.gpkg
ph_hex <- st_read("/kontur_population_PH_20231101.gpkg") %>% st_transform(3106)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
ph_admin <- st_read("data/kontur_topology_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
install.packages("sf", dependencies=TRUE)
install.packages("tmap", dependencies=TRUE)
install.packages("mapview", dependencies=TRUE)
install.packages("stars", dependencies=TRUE)
install.packages("rayshader", dependencies=TRUE)
install.packages("MetBrewer", dependencies=TRUE)
install.packages("rayrender")
install.packages("extrafont", dependencies=TRUE)
install.packages("magick", dependencies=TRUE)
options(rgl.useNULL = FALSE)
require(tidyverse)
install.packages("tidyverse")
install.packages("sf")
install.packages("mapview")
install.packages("stars")
install.packages("rayshader")
install.packages("MetBrewer")
install.packages("rayrender")
install.packages("extrafont")
install.packages("magick")
options(rgl.useNULL = FALSE)
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg")
library(sf)
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
install.packages("rgl")
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
packages <- c("tidyverse", "sf", "tmap", "ggplot2", "mapview", "stars", "rayshader", "MetBrewer", "colorspace", "rayrender", "magick", "extrafont")
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
library(pkg, character.only = TRUE)
}
lapply(packages, install_if_missing)
library(sf)
# Load the population data and administrative boundaries
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
install.packages("sf", dependencies=TRUE)
install.packages("tmap", dependencies=TRUE)
install.packages("mapview", dependencies=TRUE)
install.packages("stars", dependencies=TRUE)
install.packages("rayshader", dependencies=TRUE)
install.packages("MetBrewer", dependencies=TRUE)
install.packages("rayrender")
install.packages("extrafont", dependencies=TRUE)
install.packages("magick", dependencies=TRUE)
install.packages("rgl")
install.packages("extrafont", dependencies = TRUE)
install.packages("MetBrewer", dependencies = TRUE)
install.packages("rgl")
options(rgl.useNULL = FALSE)
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
library(sf)
# Load the population data and administrative boundaries
ph_hex <- st_read("data/kontur_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
ph_admin <- st_read("data/kontur_topology_boundaries_PH_20230628.gpkg") %>% st_transform(3106)
distinct_names <- ph_admin %>% distinct(name_en)
View(ph_hex)
View(ph_admin)
distinct_names <- ph_hex %>% distinct(name_en)
print(distinct_names)
# Creating BD Boundary
ph_boundary <- ph_admin %>%
st_geometry %>%
st_union %>%
st_sf %>%
st_make_valid()
names(ph_hex)
ggplot(ph_hex) +
geom_sf(aes(fill = population), color = "gray66", linewidth = 0) +
geom_sf(data = ph_boundary, fill = NA, color = "black")
# setting the ph boundary as a bounding box
bbox <- st_bbox(ph_boundary)
# finding the aspect ratio
bottom_left <- st_point(c(bbox[["xmin"]], bbox[["ymin"]])) %>%
st_sfc(crs = 3106)
bottom_right <- st_point(c(bbox[["xmax"]], bbox[["ymin"]])) %>%
st_sfc(crs = 3106)
top_left <- st_point(c(bbox[["xmin"]], bbox[["ymax"]])) %>%
st_sfc(crs = 3106)
top_right <- st_point(c(bbox[["xmin"]], bbox[["ymax"]])) %>%
st_sfc(crs = 3106)
width <- st_distance(bottom_left, bottom_right)
height <- st_distance(bottom_left, top_left)
if(width > height) {
w_ratio = 1
h_ratio = height / width
} else {
h_ratio = 1.1
w_ratio = width / height
}
# setting the ph boundary as a bounding box
bbox <- st_bbox(ph_boundary)
# finding the aspect ratio
bottom_left <- st_point(c(bbox[["xmin"]], bbox[["ymin"]])) %>%
st_sfc(crs = 3106)
bottom_right <- st_point(c(bbox[["xmax"]], bbox[["ymin"]])) %>%
st_sfc(crs = 3106)
top_left <- st_point(c(bbox[["xmin"]], bbox[["ymax"]])) %>%
st_sfc(crs = 3106)
top_right <- st_point(c(bbox[["xmin"]], bbox[["ymax"]])) %>%
st_sfc(crs = 3106)
width <- st_distance(bottom_left, bottom_right)
height <- st_distance(bottom_left, top_left)
if(width > height) {
w_ratio = 1
h_ratio = height / width
} else {
h_ratio = 1.1
w_ratio = width / height
}
# convert to raster to convert to matrix
size = 3500
pop_raster <- st_rasterize(
ph_hex,
nx = floor(size * w_ratio) %>% as.numeric(),
ny = floor(size * h_ratio) %>% as.numeric()
)
pop_matrix <- matrix(pop_raster$population,
nrow = floor(size * w_ratio),
ncol = floor(size * h_ratio))
# setting the ph boundary as a bounding box
bbox <- st_bbox(ph_boundary)
# finding the aspect ratio
bottom_left <- st_point(c(bbox[["xmin"]], bbox[["ymin"]])) %>%
st_sfc(crs = 3106)
bottom_right <- st_point(c(bbox[["xmax"]], bbox[["ymin"]])) %>%
st_sfc(crs = 3106)
top_left <- st_point(c(bbox[["xmin"]], bbox[["ymax"]])) %>%
st_sfc(crs = 3106)
top_right <- st_point(c(bbox[["xmin"]], bbox[["ymax"]])) %>%
st_sfc(crs = 3106)
width <- st_distance(bottom_left, bottom_right)
height <- st_distance(bottom_left, top_left)
if(width > height) {
w_ratio = 1
h_ratio = height / width
} else {
h_ratio = 1.1
w_ratio = width / height
}
# convert to raster to convert to matrix
size = 3500
pop_raster <- st_rasterize(
ph_hex,
nx = floor(size * w_ratio) %>% as.numeric(),
ny = floor(size * h_ratio) %>% as.numeric()
)
pop_matrix <- matrix(pop_raster$population,
nrow = floor(size * w_ratio),
ncol = floor(size * h_ratio))
# Create color palette from MetBrewer Library
color <- MetBrewer::met.brewer(name="OKeeffe1", direction = -1)
tx <- grDevices::colorRampPalette(color, bias = 4.5)(256)
swatchplot(tx)
swatchplot(color)
# Close any existing 3D plot before plotting another
rgl::close3d()
# Close any existing 3D plot before plotting another
rgl::close3d()
options(rgl.useNULL = FALSE)
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
library(sf)
# Load the population data and administrative boundaries
gl_hex <- st_read("packages/kontur_population_GL_20231101.gpkg") %>% st_transform(3106)
gl_admin <- st_read("packages/kontur_boundaries_GL_20230628.gpkg") %>% st_transform(3106)
distinct_names <- gl_admin %>% distinct(name_en)
print(distinct_names)
# Creating BD Boundary
gl_boundary <- gl_admin %>%
st_geometry %>%
st_union %>%
st_sf %>%
st_make_valid()
gl_boundary %>%
ggplot()+
geom_sf()
gndlnd_hex <- st_intersection(gl_hex, gl_boundary) %>%
st_transform(crs = 3106)
ggplot(gl_hex)+
geom_sf(aes(fill = population),
color = "grey66",
linewidth = 0)
geom_sf(
data = gl_boundary,
fill = NA,
color = "black",
linetype = "dashed",
linewidth = 1
)
options(rgl.useNULL = FALSE)
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
library(sf)
# Load the population data and administrative boundaries
ca_hex <- st_read("packages/kontur_population_CA_20231101.gpkg") %>% st_transform(3106)
options(rgl.useNULL = FALSE)
require(tidyverse)
require(sf)
require(tmap)
require(ggplot2)
require(mapview)
require(stars)
require(rayshader)
require(MetBrewer)
require(colorspace)
require(rayrender)
require(magick)
require(extrafont)
library(sf)
# Load the population data and administrative boundaries
gr_hex <- st_read("packages/kontur_population_GR_20231101.gpkg") %>% st_transform(3106)
gr_admin <- st_read("packages/kontur_boundaries_GR_20230628.gpkg") %>% st_transform(3106)
distinct_names <- gr_admin %>% distinct(name_en)
print(distinct_names)
# Creating BD Boundary
gr_boundary <- gr_admin %>%
st_geometry %>%
st_union %>%
st_sf %>%
st_make_valid()
gr_boundary %>%
ggplot()+
geom_sf()
grc_hex <- st_intersection(gr_hex, gr_boundary) %>%
st_transform(crs = 3106)
